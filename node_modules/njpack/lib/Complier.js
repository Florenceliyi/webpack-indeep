const fs = require("fs");
const ejs = require("ejs");
const path = require("path");
const parser = require("@babel/parser");
const traverse =  require("@babel/traverse").default;
const generate = require('@babel/generator').default;
const t = require('@babel/types');

class Complier{
    constructor(config) {
        this.config = config
        this.modules = {}
    }
    run(){
        this.buildModule()
        this.writeFile()
    }
    //读取文件内容的方法
    getSource(filePath){
        return fs.readFileSync(filePath, 'utf8')
    }
    buildModule(){
        const code = this.getSource(this.config.entry)
        this.modules[this.config.entry] = code
        this.parseModule(code)
        // console.log(this.modules);
    }
    writeFile(){
        //1.读取ejs模板内容
        const templatePath = path.resolve(__dirname, "main.ejs")
        const templContent = fs.readFileSync(templatePath, 'utf8')
        //2.用变量替换模板中的内容
        const resultCode = ejs.render(templContent, {entryId: this.config.entry, modules: this.modules}) 
        //3. 获取出口目录
        const outputDir = this.config.output.path
        //4. 没有出口文件要创建出口文件
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir)
        }
        const outputPath = path.resolve(outputDir, this.config.output.filename)
        //5. 写入文件内容
        fs.writeFileSync(outputPath, resultCode)
    }
    parseModule(code){
        //1. 将当前的代码转换成抽象语法树
        const astTree = parser.parse(code)
        //2. 保存主模块地址
        const mainPath = path.dirname(this.config.entry)
        //3. 定义数组保存当前模块的所有依赖
        const dependencies = []
        //4. 修改抽象语法树的内容
        traverse(astTree, {
            CallExpression(nodePath){
                console.log('nodePath',nodePath.node);
            }
        })
    }
}

// console.log(module.exports);
module.exports = Complier